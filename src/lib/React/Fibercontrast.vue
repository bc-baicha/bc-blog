<template>
  <PageTitle text="为什么VUE不使用Fiber？" />
  <Pagecontent>
    <h3>react vue 响应式原理</h3>
    <Tagtext>
      从底层实现来看修改数据：在react中，组件的状态是不能被修改的，setState没有修改原来那块内存中的变量，而是去新开辟一块内存；
      而vue则是直接修改保存状态的那块原始内存。
    </Tagtext>
    <div>
      所以经常能看到react相关的文章里经常会出现一个词"immutable"，翻译过来就是不可变的。
    </div>
    <h4>react视图的更新：</h4>
    <Tagtext>
      react中，调用setState方法后，会自顶向下重新渲染组件，自顶向下的含义是，该组件以及它的子组件全部需要渲染；
    </Tagtext>
    <h4>Vue视图的更新：</h4>
    <Tagtext>
      vue使用Object.defineProperty（vue@3迁移到了Proxy）对数据的设置（setter）和获取（getter）做了劫持，也就是说，vue能准确知道视图模版中哪一块用到了这个数据，并且在这个数据修改时，告诉这个视图，你需要重新渲染了。
    </Tagtext>
    <p>
      所以当一个数据改变，react的组件渲染是很消耗性能的——父组件的状态更新了，所有的子组件得跟着一起渲染，它不能像vue一样，精确到当前组件的粒度。
    </p>
    <h3>不同响应式原理的影响</h3>
    <div>
      上文中提到的“渲染”“render”“更新“都不是指浏览器真正渲染出视图。而是框架在javascript层面上，调用自身实现的render方法，生成一个普通的对象，这个对象保存了真实dom的属性，也就是常说的虚拟dom。本文会用组件渲染和页面渲染对两者做区分。
    </div>
    <p>每次更新视图的流程是这样的：</p>
    <ul>
      <li>1、组件渲染生成一棵新的虚拟dom树；</li>
      <li>2、新旧虚拟dom树对比，找出变动的部分；（也就是常说的diff算法）</li>
      <li>
        3、为真正改变的部分创建真实dom，把他们挂载到文档，实现页面重渲染；
      </li>
    </ul>
    <p>
      由于react和vue的响应式实现原理不同，数据更新时，第一步中react组件会渲染出一棵更大的虚拟dom树。
    </p>
    <div v-viewer>
      <img src="../../assets/fiber/Fiber.jpeg" alt="" />
    </div>
    <h3>Fiber出现的原因：</h3>
    <div>
      react在更新数据时，如果该组件是父组件那么它所有的子组件都要在此次更新的dom树中，给第二步的diff--我们想找到真正变化的部分带来了不必要的困难，需要花费更长的时间。js占据主线程去做比较，渲染线程便无法做其他工作，用户的交互得不到响应，影响到了用户的体验。
    </div>
    <h3>Fiber的作用：</h3>
    <div>
      Fiber没法让比较的时间缩短，但它使得diff的过程被分成一小段一小段的，因为它有了“保存工作进度”的能力。js会比较一部分虚拟dom，如果有优先级高的任务接入，就把主线程的控制权还给浏览器去做其他工作，工作完成之后重新得到控制权继续比较，依次往复，等到最后比较完成，一次性更新到视图上。
    </div>
    <h3>Fiber是一种新的数据结构：</h3>
    <div v-viewer>
      <img src="../../assets/fiber/1.jpeg" alt="" />
    </div>
    <p>
      在老的架构中，节点是以树的形式被组织起来：每个节点上有多个指针指向子节点。<br />
      要找到两棵树的变化部分，最容易想到的办法就是深度优先遍历，规则如下：
    </p>
    <ul>
      <li>1、从根节点开始，依次遍历该节点的所有子节点；</li>
      <li>2、当一个节点的所有子节点遍历完成，才认为该节点遍历完成；</li>
    </ul>
    <p>
      这种遍历有一个特点，必须一次性完成。假设遍历发生了中断，虽然可以保留当下进行中节点的索引，下次继续时，我们的确可以继续遍历该节点下面的所有子节点，但是没有办法找到其父节点——因为每个节点只有其子节点的指向。断点没有办法恢复，只能从头再来一遍。
    </p>
    <div v-viewer>
      <img src="../../assets/fiber/2.jpeg" alt="" />
    </div>
    <p>
      在遍历到节点2时发生了中断，我们保存对节点2的索引，下次恢复时可以把它下面的3、4节点遍历到，但是却无法找回5、6、7、8节点。
    </p>
    <div v-viewer>
      <img src="../../assets/fiber/3.jpeg" alt="" />
    </div>
    <p>
      在新的架构中，每个节点有三个指针：分别指向第一个子节点、下一个兄弟节点、父节点。这种数据结构就是fiber，它的遍历规则如下：
    </p>
    <ul>
      <li>
        1、从根节点开始，依次遍历该节点的子节点、兄弟节点，如果两者都遍历了，则回到它的父节点；
      </li>
      <li>2、当一个节点的所有子节点遍历完成，才认为该节点遍历完成；</li>
    </ul>
    <p>
      根据这个规则，同样在图中标出了节点遍历完成的顺序。跟树结构对比会发现，虽然数据结构不同，但是节点的遍历开始和完成顺序一模一样。不同的是，当遍历发生中断时，只要保留下当前节点的索引，断点是可以恢复的——因为每个节点都保持着对其父节点的索引。
    </p>
    <div v-viewer>
      <img src="../../assets/fiber/4.jpeg" alt="" />
    </div>
    <p>
      同样在遍历到节点2时中断，fiber结构使得剩下的所有节点依旧能全部被走到。<br />
      这就是reactfiber的渲染可以被中断的原因。树和fiber虽然看起来很像，但本质上来说，一个是树，一个是链表。
    </p>
    <div v-viewer>
      <img src="../../assets/fiber/5.jpeg" alt="" />
    </div>
    <h3>Vue精准更新：</h3>
    <ul>
      <li>
        1、给每一个组件配置一个"监听器",管理着视图的依赖收集和数据更新时的发布通知
      </li>
      <li>2、通过模板语法静态编译，实现收集依赖。</li>
    </ul>
  </Pagecontent>
</template>
